# 一、冒泡排序法
## 1、冒泡排序法的工作原理：
反复比较待排序数组中所有相邻的两个数据，使他们按升序（或降序）排列，当待排序数组中所有相邻数据都比较过一次之后，待排序数组中最小（最大）的数据会逐步交换到第一位，就像旗袍从水底慢慢升到水面上。

1. N个数字来排队，两两相比小靠前，外层循环N-1，内层循环N-1-i；

2. 利用二重循环将5个数字排序 N-5。
## 2、图解：
|外层循环（表示循环的趟数）|i=？|比较次数|循环次数|内层循环（表示冒泡的处理）|
|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|
|i<4|i=0|第一轮：比较了4次|循环4次：j<4|j<4-i|
|i<N-1|i=1|第二轮：比较了3次|循环3次：j<3|j<N-1-i|
|i<4|i=2|第三轮：比较了2次|循环2次：j<2|j<N-1-i|
|i<N-1|i=3|第四轮：比较了1次|循环1次：j<1|j<4-i|
## 3、相关代码：
```c#
//冒泡排序
class EbullitionsSorter
    {
        public static void Sort(int[] arr)
        {
            int temp = 0;
            //外循环表示循环的趟数
            for (int i = 0; i < arr.Length - 1; i++)
            {
                //内循环表示冒泡的处理
                for (int j = 0; j < arr.Length - i - 1; j++)
                {
                    //通过比较大小，实现元素交换
                    if (arr[j] > arr[j + 1])
                    {
                        temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
            }
        }
    }
class Demo
{
    static void Main(string[] args)
    {
        //冒泡排序
        Console.WriteLine("冒泡排序：");
        int[] arr4 = new int[] { 2, 34, 456, 3320, 2675, 3268 };
        EbullitionsSorter.Sort(arr4);
        //利用for循环将元素逐个显示出来
        for (int a = 0; a < arr4.Length; a++)
        {
            Console.WriteLine(arr4[a] + "\t");
        }
    }
}
```
* * *
# 二、插入排序法
## 1、插入排序法的工作原理
1. 将数组分为有序和无序两部分，通过迭代，不断将无序部分的首元素插入有序部分中；
2. 每次迭代时，有序部分元素数量加一，无序部分元素数量减一，若有几个元素，那么要迭代N次；
3. 无序部分减少的那个元素可以按照从左到右的顺序一个个取；
4. 有序部分增加的那个元素需要从右往左一个个比较确定位置，也就是有序向量的插入方法；
5. 实际上对于某个无序数组，可以看作由有序部分+无序部分组成，刚看到这个数组时，从左到右，有序部分元素数量为0，无序部分元素数量为N。
## 2、图表
||插入排序算法实例||
|:-------:|-------:|:-------|
|迭代|前缀有序子序列|后缀无序子序列|
|0|^|【5】 2 7 4 6 3 1|
|1|【5】|【2】 7 4 6 3 1|
|2|【2】 5|【7】 4 6 3 1|
|3|2 5 【7】|【4】 6 3 1|
|4|2 【4】 5 7|【6】 3 1|
|5|2 4 5 【6】 7|【3】 1|
|6|2 【3】 4 5 6 7|【1】|
|7|【1】 2 3 4 5 6 7|^|
## 3、相关代码
```c#
//插入排序
class InsertionSorter
{
    public static void Sort(int[] arr)
    {
        int temp;//预备插入有序数组中的数
        int j;//下标
              //插入排序是把无序的数一个个插入到有序的数
              //先默认下标为0的这个数已经有序（把无序数组中的第一个数（从左向右数）拿出来，放到有序数组中的最右侧）
              //自无序数组中的第二个数开始比较
        for (int i = 1; i < arr.Length; i++)
        {
            temp = arr[i];
            j = i - 1;
            //当下标>=0并且arr[1]<arr[0]
            //也就是当第二个数<有序数组中的数
            //用<确保相同元素的相对次序不变，而不用<=
            while (j >= 0 && temp < arr[j])
            {
                //将大的元素向后移，而不是每比较完就交换
                arr[j + 1] = arr[j];
                j--;//从右往左比较，所以--，而不是++
            }
            //插入  找到合适的位置
            arr[j + 1] = temp;
        }
    }
} 
class Demo
{
    static void Main(string[] args)
    {
        //插入排序
        Console.WriteLine("插入排序：");
        int[] arr2 = new int[5] { 6, 9, 4, 2, 3 };
        InsertionSorter.Sort(arr2);
        for (int a = 0; a < arr2.Length; a++)
        {
            int b = a + 1;
            Console.WriteLine("第" + b + "个数：" + arr2[a]);
        }
    }
}
```
* * *
# 三、选择排序法
## 1、选择排序法的工作原理
1. 首先，在未排序序列找到最小（最大）元素，存放到排序序列的起始位置；
2. 然后，再从剩余未排序元素中继续寻找最小（最大）元素，并放到已排序的末尾；
3. 以此类推，直到所有元素均排序完毕，选择排序的主要优点与数据移动有关；
4. 如果某个元素位于正确的最终位置上，则它不会被移动；
5. 选择排序每次交换一对元素，他们当中至少一个被移动到最终位置上，因此对N个元素进行排序，总共进行至多N-1次交换。
## 2、图表
|原始数据：|【5】   9   10   7   8   12   6   【3】|
|:-------:|:-------:|
|步骤1：|从所有数据中选择最小的放在第一个位置|
|第一次排序结果：|3    【9】    10    7    8    12    6    【5】|
|步骤2：|从剩余数据中选择最小的放在第二个位置|
|第二次排序结果：|3    5    【10】    7    8    12    【6】    9|
|步骤3：|从剩余数据中选择最小的放在第三个位置|
|第三次排序结果：|3    5    6    7    8    【12】    10    【9】|
|步骤4：|从剩余数据中选择最小的放在第六个位置|
|第四次排序结果：|3    5    6    7    8    9    10    12|
## 3、相关代码
```c#
//选择排序
class SelectionSorter
{
    public static void Sort(int[] arr)
    {
        int temp;
        int minVal;
        int index;
        for (int i = 0; i < arr.Length - 1; i++)
        {
            minVal = arr[i];//假设i下标就是最小的数
            index = i;//记录我认为最小的数的下标
                      //找出这一趟最小的数值并记录下他的下标
            for (int j = i + 1; j < arr.Length; j++)
            {
                //说明我们认为的最小值，不是最小
                //这里大于号是升序（大于是找出最小值） 小于号是降序（小于是找出最大值）
                if (minVal > arr[j])
                {
                    minVal = arr[j];//更新这趟最小（或最大）的值（上面要拿这个数来跟后面的数继续做比较）
                    index = j;//记下它的坐标
                }
            }
            temp = arr[i];//把第一个原先认为是最小值的数，临时保存起来
            arr[i] = arr[index];//把最终找到的最小值赋给这一趟的比较的第一个位置
            arr[index] = temp;//把原先保存好临时数值放回此数组的空地方，保证数组的完整性
        }
    }
}
class Demo
{
    static void Main(string[] args)
    {
        //选择排序
        Console.WriteLine("选择排序：");
        int[] arr5 = new int[8] { 15, 0, 10, 50, 55, 35, 12, 20 };//待排序数组
        SelectionSorter.Sort(arr5);
        foreach (int item in arr5)
        {
            Console.WriteLine(item);
        }
    }
}
```
* * *
# 四、希尔排序法
## 1、希尔排序法的工作原理
希尔排序算法是将数组的所有元素按照一定增量（gap）分组，对每组内的数据实行插入排序，之后不断减小增量，每组内所包含的元素越来越多，增量减少至1时，整个数组被分为一组，插入排序后整个数组的排序便完成。
## 2、图表
|初始：|9    1    2    5    7    4    8    6    3    【5】|
|:-------:|:-------:|
|gap=10/2=5  每隔5个|9、4    1、8    2、6    5、3    7、【5】|
|第一次排序结果：|4    1    2    3    【5】    9    8    6    5    7|
|gap=5/2=2  每隔2个|4、2、【5】、8、5     1、3、9、6、7|
|第二次排序结果：|2    1    4    3    【5】    6    5    7    8    9|
|gap=2/2=1  每隔1个|2、1、4、3、5、6、5、7、8、9|
|第三次排序结果：|1    2    3    4    【5】    5    6    7    8    9|
1. 初始时有一个大小为10的无序序列；
2. 在第一趟排序中，设增量gap=N/2=5，即相隔距离为5的元素为一组，可以分为5组，接着按照插入排序的方法对每个组进行排序；
3. 在第二趟排序中，设增量gap=N/2=2（取整数），即相隔距离为2的元素为一组，可以分为2组，接着按照插入排序的方法对每个组进行排序；
4. 在第三趟排序中，设增量gap=N/2=1，即相隔距离为1的元素为一组，可以分为1组，接着按照插入排序的方法对每个组进行排序；
注意：图中有两个相等数值的元素5和【5】，在排序过程中，两个元素位置交换了，所以希尔排序是不稳定的算法。
## 3、相关代码
```c#
//希尔排序
class ShellSorter
{
    public static void Sort(int[] arr)
    {
        int gap = arr.Length / 2;
        while (gap >= 1)
        {
            //把距离为gap的元素编为一个组，扫描所有组
            for (int i = gap; i < arr.Length; i++)
            {
                int temp = arr[i];//存储和其比较的上一个元素
                int j = 0;
                //对距离为gap的元素组进行排序
                for (j = i - gap; j >= 0 && temp < arr[j]; j = j - gap)
                {
                    arr[j + gap] = arr[j];
                }
                arr[j + gap] = temp;
            }
            gap = gap / 2;//减小增量
        }
    }
}
class Demo
{
    static void Main(string[] args)
    {
        //希尔排序
        Console.WriteLine("希尔排序：");
        int[] arr3 = new int[] { 9, 1, 2, 5, 7, 4, 8, 6, 3, 5 };
        ShellSorter.Sort(arr3);
        foreach (int n in arr3)
        {
            Console.WriteLine(n);
        }
    }
}
```
* * *
# 五、快速排序
## 1、快速排序法的工作原理

1. 设置两个变量i、j，排序开始的时候：i=0，j=N-1；
2. 以第一个数组元素作为关键数据，赋值给key，即key=A[0]；
3. 从j开始向前搜索，即由后开始向前搜索（j--），找到第一个小于key的值A[j]，将A[j]和A[i]互换；
4. 从i开始向前搜索，即由后开始向前搜索（i++），找到第一个大于key的值A[i]，将A[i]和A[j]互换；
5. 重复第3、4步，直到i=j；（if 3、4步中，没找到符合条件的值，即3中A[j]不小于key，4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候，i、j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束。）
## 2、图表
|原序列|【12】    20    5    16    15    1    30    45|
|:-------:|:-------:|
|基准值12|把12挖出来，与其它数做对比|
|第一次从后往前|12与45比，45没有小于基准值，继续比较下一个，直到遇到第一个比基准值小的1，交换位置|
|第一次排序结果|1    20    5    16    15    【】    30    45|
|j值|j=5|
|第二次从前往后|下标为1的20大于基准值，交换位置|
|第二次排序结果|1    【】    5    16    15    20    30    45|
|i值|i=1|
|第三次从后往前|下标为2的5小于基准值，交换位置|
|第二次排序结果|1    5    【】    16    15    20    30    45|
|j值|j=2|
|第四次从前往后|没有比基准值大的数，第一轮排序结束|
|j?i|j=i=2|
|第一轮排序结果|【1    5】    【】    【16    15    20    30    45】|
## 3、相关代码
```c#
//快速排序
class QuickSorter
{
    public static void SordPX(int[] arr, int left, int right)
    {
        //将数组第一个数给临时变量temp，并找到temp的索引位置
        int temp = arr[left];//自左侧挖一个坑(将15拿出来同接下来的数值作比较)
        int i = left;
        int j = right;
        //疯狂挖坑
        while (i < j)
        {
            //后标记前移
            while (arr[j] >= temp && i < j)
            {
                j--;
            }
            if (arr[j] <= temp)
            {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;//填上最后的坑（找到中心15）
            }
            //前标记后移
            while (arr[i] <= temp && i < j)
            {
                i++;
            }
            if (arr[j] <= temp)
            {
                temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;//填上最后的坑（找到中心15）
            }
        }
        //递归（直接或间接的调用自己的算法）
        if (i > left)
        {
            SordPX(arr, left, i - 1);
        }
        if (j < right)
        {
            SordPX(arr, j + 1, right);
        }
    }
}
class Demo
{
    static void Main(string[] args)
    {
        //快速排序
        Console.WriteLine("快速排序：");
        int[] arr1 = new int[] { 15, 7, 32, 72, 12, 65, 28, 125, 2, 57 };
        QuickSorter.SordPX(arr1, 0, arr1.Length - 1);
        for (int i = 0; i < arr1.Length; i++)
        {
            Console.WriteLine(arr1[i] + "\t");
        }
    }
}
```